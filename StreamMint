git remote add origin https://github.com/Nico81018/StreamMint.git
 git branch -M main 
git push -u origin main

#!/usr/bin/env bash
set -e

GIT_REMOTE_URL="https://github.com/Nico81018/StreamMint.git"
BRANCH=${1:-main}

echo "[1/4] Inizializzo repository Git localeâ€¦"
if [ ! -d .git ]; then
  git init
  git checkout -b $BRANCH
fi

echo "[2/4] Aggiungo file e creo commitâ€¦"
git add -A
if ! git rev-parse --verify HEAD >/dev/null 2>&1; then
  git commit -m "Initial import: StreamMint (full app + infra)"
else
  git commit -m "Update: StreamMint" || echo "Nessuna modifica"
fi

echo "[3/4] Imposto remote originâ€¦"
git remote remove origin 2>/dev/null || true
git remote add origin "$GIT_REMOTE_URL"

echo "[4/4] Push sul repository GitHubâ€¦"
git push -u origin $BRANCH --force

echo "ðŸŽ‰ Push completato! Repo: $GIT_REMOTE_URL (branch: $BRANCH)"

#!/usr/bin/env bash
set -e

REPO="Nico81018/StreamMint"

echo "Inserisci SPOTIFY_CLIENT_ID:"
read SPOTIFY_CLIENT_ID
echo "Inserisci SPOTIFY_CLIENT_SECRET:"
read SPOTIFY_CLIENT_SECRET

echo "Inserisci GOOGLE_CLIENT_ID:"
read GOOGLE_CLIENT_ID
echo "Inserisci GOOGLE_CLIENT_SECRET:"
read GOOGLE_CLIENT_SECRET

echo "Inserisci TANGO_API_KEY:"
read TANGO_API_KEY
echo "Inserisci TANGO_SENDER_ID:"
read TANGO_SENDER_ID
echo "Inserisci TANGO_WEBHOOK_SECRET:"
read TANGO_WEBHOOK_SECRET

echo "Inserisci DATABASE_URL:"
read DATABASE_URL
echo "Inserisci REDIS_URL:"
read REDIS_URL

SESSION_KEY=$(openssl rand -hex 32)

echo "Imposto secrets su GitHubâ€¦"

gh secret set SPOTIFY_CLIENT_ID --repo $REPO --body "$SPOTIFY_CLIENT_ID"
gh secret set SPOTIFY_CLIENT_SECRET --repo $REPO --body "$SPOTIFY_CLIENT_SECRET"
gh secret set GOOGLE_CLIENT_ID --repo $REPO --body "$GOOGLE_CLIENT_ID"
gh secret set GOOGLE_CLIENT_SECRET --repo $REPO --body "$GOOGLE_CLIENT_SECRET"
gh secret set TANGO_API_KEY --repo $REPO --body "$TANGO_API_KEY"
gh secret set TANGO_SENDER_ID --repo $REPO --body "$TANGO_SENDER_ID"
gh secret set TANGO_WEBHOOK_SECRET --repo $REPO --body "$TANGO_WEBHOOK_SECRET"
gh secret set DATABASE_URL --repo $REPO --body "$DATABASE_URL"
gh secret set REDIS_URL --repo $REPO --body "$REDIS_URL"
gh secret set SESSION_KEY --repo $REPO --body "$SESSION_KEY"

echo "ðŸŽ‰ Secrets configurati correttamente!"

#!/usr/bin/env bash
set -e

echo "ðŸš€ StreamMint â€” Setup Infrastruttura Locale"

echo "[1/5] Avvio Docker Composeâ€¦"
docker compose up -d

echo "[2/5] Attesa Postgresâ€¦"
until docker exec $(docker ps -qf "name=postgres") pg_isready -U postgres >/dev/null 2>&1; do
  echo "Attesa che Postgres sia prontoâ€¦"
  sleep 2
done

echo "[3/5] Eseguo migrazione SQL inizialeâ€¦"
docker exec -i $(docker ps -qf "name=postgres") psql -U postgres -d streammint < backend/sql/migrations/001_init.sql

echo "[4/5] Verifica stato serviziâ€¦"
curl -s http://localhost:4000/health || echo "Backend non ancora pronto"

echo "[5/5] Completato!"
echo "ðŸŽ‰ Infrastruttura pronta: http://localhost:5173"

./setup_infra.sh

"dependencies": {
  "otplib": "^12.0.1",
  "qrcode": "^1.5.1",
  "ioredis": "^5.0.0",
  "pg": "^8.0.0",
  "bcryptjs": "^2.4.3",
  "jsonwebtoken": "^9.0.0"
}

psql "${DATABASE_URL}" -f backend/sql/migrations/001_init.sql
node backend/src/seed_admin.js

cd /percorso/del/tuo/progetto/StreamMint

# 1) crea branch per i cambiamenti
git checkout -b feature/admin-2fa-logging-seed

# 2) copia/estrai i file del pacchetto (se ancora non lo hai fatto)
# Assumendo che lo zip sia nella stessa macchina, decomprimi nella root:
unzip /path/to/streammint_full_update_v2.zip -d .

# 3) aggiungi i nuovi file e fai commit
git add -A
git commit -m "Feat: admin dashboard, 2FA, rate-limiter, seeder, logging + assets"

# 4) push del branch
git push -u origin feature/admin-2fa-logging-seed

# 5) apri PR (richiede gh CLI)
gh pr create --title "Admin: 2FA, rate-limit, admin API, assets" --body "Aggiunta admin, 2FA TOTP, rate-limiter Redis, seeder, logo e documentazione." --base main

git diff --staged > streammint_changes.patch
# inviami il contenuto o applicalo su un altro clone con:
git apply streammint_changes.patch

REPO="Nico81018/StreamMint"

gh secret set SPOTIFY_CLIENT_ID --repo $REPO --body "your_spotify_client_id"
gh secret set SPOTIFY_CLIENT_SECRET --repo $REPO --body "your_spotify_client_secret"
gh secret set GOOGLE_CLIENT_ID --repo $REPO --body "your_google_client_id"
gh secret set GOOGLE_CLIENT_SECRET --repo $REPO --body "your_google_client_secret"
gh secret set TANGO_API_KEY --repo $REPO --body "your_tango_api_key"
gh secret set TANGO_SENDER_ID --repo $REPO --body "your_tango_sender_id"
gh secret set TANGO_WEBHOOK_SECRET --repo $REPO --body "your_tango_webhook_secret"
gh secret set DATABASE_URL --repo $REPO --body "postgres://postgres:password@host:5432/streammint"
gh secret set REDIS_URL --repo $REPO --body "redis://:password@host:6379"
gh secret set SESSION_KEY --repo $REPO --body "$(openssl rand -hex 32)"

# backend
cd backend
# aggiungi le dipendenze raccomandate
npm install otplib qrcode ioredis pg bcryptjs jsonwebtoken axios
# (se mancano nodemon per sviluppo)
npm install --save-dev nodemon

"scripts": {
  "start": "node src/index.js",
  "dev": "nodemon src/index.js",
  "seed": "node src/seed_admin.js",
  "test": "node src/tests/antifraud.test.js"
}

cd ../frontend
npm install
# per Vite dev:
npm run dev
docker compose up -d --build

export DATABASE_URL="postgres://postgres:password@localhost:5432/streammint"
psql "${DATABASE_URL}" -f backend/sql/migrations/001_init.sql

# assicurati DATABASE_URL impostato
cd backend
npm run seed
# output: "Seed complete"

# health check backend
curl http://localhost:4000/health
# test admin login (example)
curl -X POST http://localhost:4000/admin/login -H "Content-Type: application/json" -d '{"email":"admin@example.com","password":"admin123"}'
# should return { "token": "..." }

cd backend
npm install winston express-winston

// backend/src/logger.js
const winston = require('winston');

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console()
    // in prod: add file or remote transport (Datadog/LogDNA)
  ],
});

module.exports = logger;

const logger = require('./logger');
logger.info('Starting backend', { env: process.env.NODE_ENV });

npm install @sendgrid/mail

// backend/src/services/email.js
const sgMail = require('@sendgrid/mail');
sgMail.setApiKey(process.env.SENDGRID_API_KEY);

async function sendRewardFulfilled(toEmail, subject, plainText, html){
  const msg = {
    to: toEmail,
    from: process.env.EMAIL_FROM || 'no-reply@streammint.io',
    subject,
    text: plainText,
    html
  };
  return sgMail.send(msg);
}

module.exports = { sendRewardFulfilled };

const { sendRewardFulfilled } = require('./services/email');
// ...
await sendRewardFulfilled(recipient_email, 'Il tuo voucher Ã¨ arrivato', '... testo ...', '<b>...</b>');

chmod +x auto-pr.sh

#!/usr/bin/env bash
set -e

# Usage: ./auto-pr.sh "feature/descrizione" "Titolo PR" "Descrizione lunga"
BRANCH=${1:-feature/admin-2fa-logging-seed}
PR_TITLE=${2:-"Admin: 2FA, rate-limit, admin API, assets"}
PR_BODY=${3:-"Aggiunte: admin API, 2FA TOTP, rate-limiter Redis, seeder, logo e documentazione."}
REMOTE=${4:-origin}
BASE=${5:-main}

echo "Creating branch: $BRANCH"
git checkout -b "$BRANCH"

echo "Staging all changes..."
git add -A

if git rev-parse --verify --quiet HEAD >/dev/null; then
  echo "Creating commit..."
  git commit -m "$PR_TITLE" || echo "No changes to commit"
else
  echo "Initial commit..."
  git commit -m "$PR_TITLE" || true
fi

echo "Pushing to $REMOTE $BRANCH..."
git remote remove "$REMOTE" 2>/dev/null || true
# If remote origin already exists, skip adding
if ! git remote | grep -q "^$REMOTE$"; then
  echo "Please add remote manually before running this script or edit the script to add it."
  exit 1
fi

git push -u "$REMOTE" "$BRANCH" --force

echo "Creating PR (GitHub CLI required: gh auth login)"
gh pr create --title "$PR_TITLE" --body "$PR_BODY" --base "$BASE" --head "$BRANCH"

echo "PR created. Done."

./auto-pr.sh feature/admin-2fa-logging-seed "Admin: 2FA + rate-limit" "Aggiunge admin 2FA, rate limiter, seeder, logger, email service"

// backend/src/logger.js
const { createLogger, format, transports } = require('winston');

const logger = createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: format.combine(
    format.timestamp(),
    format.errors({ stack: true }),
    format.splat(),
    format.json()
  ),
  transports: [
    new transports.Console()
    // In production add file/remote transports, e.g.:
    // new transports.File({ filename: 'logs/error.log', level: 'error' }),
    // new transports.File({ filename: 'logs/combined.log' })
  ],
  exceptionHandlers: [
    new transports.Console()
  ],
  rejectionHandlers: [
    new transports.Console()
  ]
});

module.exports = logger;

// backend/src/services/email.js
const sgMail = require('@sendgrid/mail');
require('dotenv').config();

const SENDGRID_API_KEY = process.env.SENDGRID_API_KEY;
const EMAIL_FROM = process.env.EMAIL_FROM || 'no-reply@streammint.io';

if (SENDGRID_API_KEY) sgMail.setApiKey(SENDGRID_API_KEY);

async function sendRewardFulfilled(toEmail, subject, plainText, html) {
  if (!SENDGRID_API_KEY) {
    console.warn('SendGrid API key not configured; skipping email send.');
    return null;
  }
  const msg = {
    to: toEmail,
    from: EMAIL_FROM,
    subject,
    text: plainText,
    html
  };
  return sgMail.send(msg);
}

module.exports = { sendRewardFulfilled };

git commit -m "Temp commit for patch"   # o fai commit come preferisci
git format-patch -1 HEAD --stdout > ../streammint_changes.patch
# oppure per diff non committato:
git diff --staged > ../streammint_changes.patch

git apply streammint_changes.patch

cd backend
npm install winston express-winston @sendgrid/mail
# se non hai giÃ : otplib qrcode ioredis pg bcryptjs jsonwebtoken
npm install otplib qrcode ioredis pg bcryptjs jsonwebtoken

const logger = require('./logger');
logger.info('Starting backend', { port: process.env.PORT || 4000 });

const { sendRewardFulfilled } = require('../services/email');
// when you detect a fulfilled order:
await sendRewardFulfilled(recipient_email, 'Il tuo voucher Ã¨ stato consegnato', 'Hai ricevuto il voucher', '<p>Hai ricevuto il voucher</p>');

streammint_full_update.patch

git apply streammint_full_update.patch

From 3f42b42a9d9cbb1e0cb677d820b00de71b6d4af0 Mon Sep 17 00:00:00 2001
From: ChatGPT <bot@streammint.ai>
Date: Sun, 24 Nov 2025 12:16:00 +0000
Subject: [PATCH] Add logger, email service, auto PR script

---
 auto-pr.sh                       | 74 ++++++++++++++++++++++++++++++++++++++++
 backend/src/logger.js            | 34 ++++++++++++++++++
 backend/src/services/email.js    | 42 +++++++++++++++++++++++
 3 files changed, 150 insertions(+)
 create mode 100755 auto-pr.sh
 create mode 100644 backend/src/logger.js
 create mode 100644 backend/src/services/email.js

diff --git a/auto-pr.sh b/auto-pr.sh
new file mode 100755
index 0000000..9c2d871
--- /dev/null
+++ b/auto-pr.sh
@@ -0,0 +1,74 @@
+#!/usr/bin/env bash
+set -e
+
+# Usage:
+#   ./auto-pr.sh "feature/branch" "PR Title" "PR body" "origin" "main"
+
+BRANCH=${1:-feature/admin-2fa-logging-seed}
+PR_TITLE=${2:-"Admin: 2FA, rate-limit, logging, seeder"}
+PR_BODY=${3:-"Added admin APIs, 2FA, Redis rate limiter, seeder, logger, and email service."}
+REMOTE=${4:-origin}
+BASE=${5:-main}
+
+echo "Creating branch: $BRANCH"
+git checkout -b "$BRANCH"
+
+echo "Staging all changes..."
+git add -A
+
+if git rev-parse --verify --quiet HEAD >/dev/null; then
+  echo "Creating commit..."
+  git commit -m "$PR_TITLE" || echo "No changes to commit"
+else
+  echo "Initial commit..."
+  git commit -m "$PR_TITLE" || true
+fi
+
+echo "Pushing to $REMOTE $BRANCH..."
+git push -u "$REMOTE" "$BRANCH" --force
+
+echo "Creating PR..."
+gh pr create \
+  --title "$PR_TITLE" \
+  --body "$PR_BODY" \
+  --base "$BASE" \
+  --head "$BRANCH"
+
+echo "Done."
+
diff --git a/backend/src/logger.js b/backend/src/logger.js
new file mode 100644
index 0000000..63bcd58
--- /dev/null
+++ b/backend/src/logger.js
@@ -0,0 +1,34 @@
+const { createLogger, format, transports } = require('winston');
+
+const logger = createLogger({
+  level: process.env.LOG_LEVEL || 'info',
+  format: format.combine(
+    format.timestamp(),
+    format.errors({ stack: true }),
+    format.splat(),
+    format.json()
+  ),
+  transports: [
+    new transports.Console()
+  ],
+  exceptionHandlers: [
+    new transports.Console()
+  ],
+  rejectionHandlers: [
+    new transports.Console()
+  ]
+});
+
+module.exports = logger;
+
diff --git a/backend/src/services/email.js b/backend/src/services/email.js
new file mode 100644
index 0000000..27ab3f3
--- /dev/null
+++ b/backend/src/services/email.js
@@ -0,0 +1,42 @@
+const sgMail = require('@sendgrid/mail');
+require('dotenv').config();
+
+const SENDGRID_API_KEY = process.env.SENDGRID_API_KEY;
+const EMAIL_FROM = process.env.EMAIL_FROM || 'no-reply@streammint.io';
+
+if (SENDGRID_API_KEY) {
+  sgMail.setApiKey(SENDGRID_API_KEY);
+}
+
+async function sendRewardFulfilled(toEmail, subject, plainText, html) {
+  if (!SENDGRID_API_KEY) {
+    console.warn('SendGrid API key missing â€” skipping email send.');
+    return null;
+  }
+
+  const msg = {
+    to: toEmail,
+    from: EMAIL_FROM,
+    subject,
+    text: plainText,
+    html
+  };
+
+  try {
+    return await sgMail.send(msg);
+  } catch (err) {
+    console.error('SendGrid error:', err);
+    throw err;
+  }
+}
+
+module.exports = {
+  sendRewardFulfilled
+};
+
--
2.34.1

streammint_full_update.patch

git apply streammint_full_update.patch

git status

git add .
git commit -m "Apply patch: logger, email service, auto PR"

streammint_patch_2_tango_fraud_admin.patch


git apply streammint_patch_2_tango_fraud_admin.patch
git add -A
git commit -m "Feat: Tango integration, webhook, advanced antifraud, admin RBAC, migrations, seeder"

From 9b1f2d3a5e6f7c8d9e0f1234567890abcdef1234 Mon Sep 17 00:00:00 2001
From: ChatGPT <bot@streammint.ai>
Date: Mon, 24 Nov 2025 13:00:00 +0000
Subject: [PATCH] Tango Card integraion, webhook, advanced anti-fraud, admin RBAC, migrations & seeder

---
 backend/sql/migrations/002_full_schema.sql       | 168 ++++++++++++++++++++++++++++++++
 backend/src/services/tango_client.js             | 133 ++++++++++++++++++++++++++
 backend/src/routes/redeem.js                     | 152 ++++++++++++++++++++++++++++++
 backend/src/routes/webhooks_tango.js             | 156 ++++++++++++++++++++++++++++++
 backend/src/antifraud_advanced.js                | 230 +++++++++++++++++++++++++++++++++++++++++++++
 backend/src/admin_rbac.js                        | 111 ++++++++++++++++++++++
 backend/src/routes_admin_extended.js             | 238 ++++++++++++++++++++++++++++++++++++++++++++++
 backend/src/seed_full.js                         | 162 +++++++++++++++++++++++++++++
 9 files changed, 1350 insertions(+)
 create mode 100644 backend/sql/migrations/002_full_schema.sql
 create mode 100644 backend/src/services/tango_client.js
 create mode 100644 backend/src/routes/redeem.js
 create mode 100644 backend/src/routes/webhooks_tango.js
 create mode 100644 backend/src/antifraud_advanced.js
 create mode 100644 backend/src/admin_rbac.js
 create mode 100644 backend/src/routes_admin_extended.js
 create mode 100644 backend/src/seed_full.js

diff --git a/backend/sql/migrations/002_full_schema.sql b/backend/sql/migrations/002_full_schema.sql
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/backend/sql/migrations/002_full_schema.sql
@@ -0,0 +1,168 @@
+-- Migration 002: Full schema additions for Tango, antifraud, device fingerprints, reward redemptions, admins
+-- Run after 001_init.sql
+
+-- users table (if not present in 001)
+CREATE TABLE IF NOT EXISTS users (
+  id SERIAL PRIMARY KEY,
+  email TEXT UNIQUE,
+  provider TEXT,
+  provider_id TEXT,
+  points INTEGER DEFAULT 0,
+  created_at TIMESTAMP DEFAULT NOW()
+);
+
+-- admins table
+CREATE TABLE IF NOT EXISTS admins (
+  id SERIAL PRIMARY KEY,
+  email TEXT UNIQUE NOT NULL,
+  password_hash TEXT NOT NULL,
+  totp_secret TEXT,
+  totp_enabled BOOLEAN DEFAULT FALSE,
+  role TEXT DEFAULT 'admin',
+  created_at TIMESTAMP DEFAULT NOW()
+);
+
+-- reward_redemptions
+CREATE TABLE IF NOT EXISTS reward_redemptions (
+  id SERIAL PRIMARY KEY,
+  user_id INTEGER REFERENCES users(id),
+  amount INTEGER NOT NULL,
+  sku TEXT,
+  status TEXT DEFAULT 'pending',
+  external_order_id TEXT,
+  created_at TIMESTAMP DEFAULT NOW(),
+  fulfilled_at TIMESTAMP
+);
+
+-- fraud_events
+CREATE TABLE IF NOT EXISTS fraud_events (
+  id SERIAL PRIMARY KEY,
+  user_id INTEGER REFERENCES users(id),
+  event_type TEXT,
+  details JSONB,
+  score NUMERIC DEFAULT 0,
+  created_at TIMESTAMP DEFAULT NOW()
+);
+
+-- device_fingerprints
+CREATE TABLE IF NOT EXISTS device_fingerprints (
+  id SERIAL PRIMARY KEY,
+  user_id INTEGER REFERENCES users(id),
+  fingerprint TEXT,
+  ip TEXT,
+  user_agent TEXT,
+  last_seen TIMESTAMP DEFAULT NOW(),
+  created_at TIMESTAMP DEFAULT NOW()
+);
+
+-- indexes to speed lookups
+CREATE INDEX IF NOT EXISTS idx_reward_external ON reward_redemptions(external_order_id);
+CREATE INDEX IF NOT EXISTS idx_fraud_user ON fraud_events(user_id);
+CREATE INDEX IF NOT EXISTS idx_device_fp ON device_fingerprints(fingerprint);
+
+-- sample lookup table for tango orders (optional)
+CREATE TABLE IF NOT EXISTS tango_orders (
+  id SERIAL PRIMARY KEY,
+  redemption_id INTEGER REFERENCES reward_redemptions(id),
+  order_id TEXT,
+  status TEXT,
+  response JSONB,
+  created_at TIMESTAMP DEFAULT NOW()
+);
+
+-- NOTE: adapt types/constraints to your production needs.
+
diff --git a/backend/src/services/tango_client.js b/backend/src/services/tango_client.js
new file mode 100644
index 0000000..2222222
--- /dev/null
+++ b/backend/src/services/tango_client.js
@@ -0,0 +1,133 @@
+/**
+ * Minimal Tango Card client for RaaS (sandbox/production)
+ * Use environment:
+ *  TANGO_API_KEY
+ *  TANGO_BASE (e.g. https://sandbox-api.tangocard.com or https://api.tangocard.com)
+ *  TANGO_SENDER_ID
+ *
+ * This client is a small wrapper demonstrating how to create orders and check status.
+ * In production use the official SDK or follow Tango's full docs for compliance.
+ */
+const axios = require('axios');
+require('dotenv').config();
+
+const TANGO_BASE = process.env.TANGO_BASE || 'https://sandbox-api.tangocard.com';
+const TANGO_API_KEY = process.env.TANGO_API_KEY || '';
+const TANGO_SENDER_ID = process.env.TANGO_SENDER_ID || '';
+
+if (!TANGO_API_KEY) {
+  console.warn('TANGO_API_KEY not configured; Tango client will fail until configured.');
+}
+
+async function createOrder({ redemptionId, recipientEmail, sku, amount }) {
+  if (!TANGO_API_KEY) throw new Error('TANGO_API_KEY missing');
+  const url = `${TANGO_BASE}/raas/v3/orders`;
+  const auth = { username: TANGO_API_KEY, password: '' };
+  const body = {
+    sender: { id: TANGO_SENDER_ID || 'SENDER_SANDBOX' },
+    recipient: { email: recipientEmail },
+    reward: { sku: sku, value: amount },
+    send: true,
+    metadata: { redemptionId: redemptionId }
+  };
+  try {
+    const resp = await axios.post(url, body, { auth, timeout: 15000 });
+    return resp.data;
+  } catch (err) {
+    // normalize error
+    const e = err.response ? err.response.data : { message: err.message };
+    const error = new Error('Tango createOrder failed');
+    error.details = e;
+    throw error;
+  }
+}
+
+async function getOrderStatus(orderId) {
+  if (!TANGO_API_KEY) throw new Error('TANGO_API_KEY missing');
+  const url = `${TANGO_BASE}/raas/v3/orders/${encodeURIComponent(orderId)}`;
+  const auth = { username: TANGO_API_KEY, password: '' };
+  const resp = await axios.get(url, { auth, timeout: 10000 });
+  return resp.data;
+}
+
+module.exports = { createOrder, getOrderStatus };
+
diff --git a/backend/src/routes/redeem.js b/backend/src/routes/redeem.js
new file mode 100644
index 0000000..3333333
--- /dev/null
+++ b/backend/src/routes/redeem.js
@@ -0,0 +1,152 @@
+const express = require('express');
+const router = express.Router();
+const db = require('../db');
+const tango = require('../services/tango_client');
+const antifraud = require('../antifraud_advanced');
+const { noteRedemption } = require('../antifraud_advanced');
+
+/*
+ POST /rewards/redeem
+ Body: { userId, sku, cost, recipientEmail, deviceFingerprint }
+ Flow:
+  - authenticate session (assumed session middleware)
+  - check points
+  - anti-fraud checks
+  - deduct points (transaction)
+  - create reward_redemptions row status=pending
+  - call Tango createOrder
+  - save tango_orders row & update redemption with external_order_id
+ */
+
+router.post('/redeem', antifraud.rateLimit({ windowSeconds: 60, maxCalls: 5 }), async (req, res) => {
+  try {
+    const { userId, sku, cost, recipientEmail, deviceFingerprint } = req.body;
+    if (!userId || !cost || !sku || !recipientEmail) return res.status(400).json({ error: 'missing_params' });
+
+    // Basic user and points check
+    const userQ = await db.query('SELECT id, points FROM users WHERE id=$1 LIMIT 1', [userId]);
+    if (userQ.rows.length === 0) return res.status(404).json({ error: 'user_not_found' });
+    const user = userQ.rows[0];
+    if (user.points < cost) return res.status(400).json({ error: 'insufficient_points' });
+
+    // Antifraud scoring / checks
+    const fraudScore = await antifraud.scoreRedemption({ userId, cost, deviceFingerprint, ip: req.ip });
+    if (fraudScore >= 80) {
+      // create fraud event and block redemption
+      await db.query('INSERT INTO fraud_events (user_id, event_type, details, score) VALUES ($1,$2,$3,$4)', [userId, 'high_risk_redeem', JSON.stringify({ cost, deviceFingerprint, ip: req.ip }), fraudScore]);
+      return res.status(403).json({ error: 'high_risk' });
+    }
+
+    // Perform DB transaction: deduct points and create redemption
+    const client = await db.pool.connect();
+    try {
+      await client.query('BEGIN');
+      await client.query('UPDATE users SET points = points - $1 WHERE id = $2', [cost, userId]);
+      const insert = await client.query('INSERT INTO reward_redemptions (user_id, amount, sku, status) VALUES ($1,$2,$3,$4) RETURNING id', [userId, cost, sku, 'pending']);
+      const redemptionId = insert.rows[0].id;
+
+      // Create Tango order
+      let tangoResp = null;
+      try {
+        tangoResp = await tango.createOrder({ redemptionId, recipientEmail, sku, amount: cost });
+        // save tango_orders and update redemption external id
+        await client.query('INSERT INTO tango_orders (redemption_id, order_id, status, response) VALUES ($1,$2,$3,$4)', [redemptionId, tangoResp.order_id || tangoResp.id || null, tangoResp.status || 'created', tangoResp]);
+        await client.query('UPDATE reward_redemptions SET external_order_id = $1 WHERE id=$2', [tangoResp.order_id || tangoResp.id || null, redemptionId]);
+      } catch (terr) {
+        // record tango failure, rollback and return error
+        await client.query('ROLLBACK');
+        // refund points
+        await db.query('UPDATE users SET points = points + $1 WHERE id = $2', [cost, userId]);
+        return res.status(502).json({ error: 'fulfillment_failed', details: terr.details || terr.message });
+      }
+
+      await client.query('COMMIT');
+      // note redemption for antifraud tracking
+      noteRedemption(req);
+      return res.json({ ok: true, redemptionId, external: tangoResp });
+    } catch (e) {
+      await client.query('ROLLBACK');
+      throw e;
+    } finally {
+      client.release();
+    }
+  } catch (err) {
+    console.error('redeem error', err);
+    return res.status(500).json({ error: 'server_error' });
+  }
+});
+
+module.exports = router;
+
diff --git a/backend/src/routes/webhooks_tango.js b/backend/src/routes/webhooks_tango.js
new file mode 100644
index 0000000..4444444
--- /dev/null
+++ b/backend/src/routes/webhooks_tango.js
@@ -0,0 +1,156 @@
+const express = require('express');
+const router = express.Router();
+const crypto = require('crypto');
+const db = require('../db');
+const logger = require('../logger');
+
+/*
+ Expected Tango webhook POSTs to /webhooks/tango
+ - Verify signature header X-Tango-Signature or x-tango-signature using HMAC-SHA256 of body and TANGO_WEBHOOK_SECRET
+ - Example payload (sandbox):
+   { order_id: "ORD-123", status: "fulfilled", recipient_email: "...", sku: "amazon_us_5", reward_value: 5 }
+ */
+
+function verifySignature(req) {
+  const secret = process.env.TANGO_WEBHOOK_SECRET || '';
+  if (!secret) return false;
+  const sig = req.headers['x-tango-signature'] || req.headers['x-signature'] || req.headers['signature'];
+  if (!sig) return false;
+  const payload = JSON.stringify(req.body);
+  const computed = crypto.createHmac('sha256', secret).update(payload).digest('hex');
+  try {
+    return crypto.timingSafeEqual(Buffer.from(computed), Buffer.from(sig));
+  } catch (e) {
+    return false;
+  }
+}
+
+router.post('/tango', express.json(), async (req, res) => {
+  try {
+    if (process.env.TANGO_WEBHOOK_SECRET) {
+      if (!verifySignature(req)) {
+        logger.warn('Tango webhook invalid signature', { ip: req.ip });
+        return res.status(403).json({ error: 'invalid_signature' });
+      }
+    }
+    const evt = req.body;
+    logger.info('Tango webhook received', { evt });
+
+    // typical fields: order_id, status, recipient_email, sku, reward_value
+    const orderId = evt.order_id || evt.id || (evt.order && evt.order.id);
+    const status = evt.status || 'fulfilled';
+    const recipient = evt.recipient_email || (evt.recipient && evt.recipient.email);
+
+    // find tango_orders row
+    const trow = await db.query('SELECT id, redemption_id FROM tango_orders WHERE order_id=$1 LIMIT 1', [orderId]);
+    if (trow.rows.length === 0) {
+      // fallback: try to find redemption by external

